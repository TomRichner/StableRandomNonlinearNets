% example call of SRRN()

close all
clear
clc

tic

%% 
seed = 7;
rng(seed,'twister');

%% Network
n = 10; % number of neurons

Lya_method = 'benettin'; % 'benettin', 'qr', or 'none'
use_Jacobian = false;

mean_in_out_degree = 4; % desired mean number of connections in and out
density = mean_in_out_degree/(n-1); % each neuron can make up to n-1 connections with other neurons
sparsity = 1-density;

EI = 0.7;
scale = 0.5/0.79782; % overall scaling factor of weights
w.EE = scale*1; % E to E. Change to scale*2 for bursting
w.EI = scale*1; % E to I connections
w.IE = scale*1; % I to E
w.II = scale*.5; % I to I
w.selfE = 0;    % self connections of E neurons
w.selfI = 0;    % self connections of I neurons

[M, EI_vec] = generate_M(n,w,sparsity, EI);
EI_vec = EI_vec(:); % make it a column

%% Time
fs = 1000; %Plotting sample frequency
dt = 1/fs;
T = [-3 7];

% Validate time interval
if not( T(1)<=0 && 0<T(2) )
    error('T(1) must be 0 or negative, and T(2) must be positive for the LLE calculation logic.')
end

nt = round((T(2)-T(1))*fs)+1; % Number of plotting samples
t = linspace(T(1), T(2), nt)'; % Plotting time vector

%% u_ex, external input, stimulation

u_ex = zeros(n, nt);
% sine and square wave stim
stim_b0 = 0.5; amp = 0.5;
dur = 3; % duration of sine
f_sin = 1.*ones(1,fs*dur);
% f_sin = logspace(log10(0.5),log10(3),fs*5);
% u_ex(1,-t(1)*fs+fs*1+(1:fix(fs*dur))) = stim_b0+amp.*sign(sin(2*pi*f_sin(1:fix(fs*dur)).*t(1:fix(fs*dur))'));
u_ex(1,-t(1)*fs+fix(fs*1)+(1:fix(fs*dur))) = stim_b0+amp.*-cos(2*pi*f_sin(1:fix(fs*dur)).*t(1:fix(fs*dur))');
u_ex = u_ex*1;
u_ex = u_ex(:,1:nt);
DC = 0.1;
u_ex = u_ex+DC;

u_ex(:,0.2*fs:0.3*fs) = u_ex(:,0.2*fs:0.3*fs) + 0.1; % a pulse to help Lyapunov exponent to find the direction.
u_ex(:,1:fs) = u_ex(:,1:fs)+1./fs.*randn(n,fs); % noise in the first second to help the network get off the trivial saddle node from ICs
u_ex = u_ex+0.001./fs.*randn(n,nt); % a tiny bit of noise to help the network get off the trivial saddle node from ICs

% noise_density = 0.02; % Define the density for sparse noise application
% u_ex = u_ex + (0.001./fs .* randn(n, nt)) .* (rand(1, nt) < noise_density); % Apply sparse noise (density ~0.02) to help the network get off the trivial saddle node from ICs


%% parameters

n_a = 3; % number of SFA timescales per neuron
n_b = 2; % number of STD timescales per neuron

tau_a = logspace(log10(0.3), log10(6), n_a); % s, 1 x n_a, time constants of SFA
tau_b = logspace(log10(0.6), log10(9), n_b);  % s, 1 x n_b, time constants of STD, n_b == 1, then it takes the last value log10(9)

tau_d = 0.01; % s, scalar

c_SFA = 1 * double(EI_vec == 1); % n x 1, 0 for I neurons bc no SFA
F_STD = 1 * double(EI_vec == 1); % n x 1, 0 for I neurons bc no STD
tau_STD = 0.5; % scalar, time constant of synaptic depression

params = package_params(n_a, n_b, tau_a, tau_b, tau_d, n, M, c_SFA, F_STD, tau_STD);

%% Initial Conditions
if n_a > 0
    a0 = zeros(n * n_a, 1);
else
    a0 = [];
end

if n_b > 0
    b0 = ones(n * n_b, 1);
else
    b0 = [];
end

u_d0 = zeros(n, 1);

X_0 = [a0; b0; u_d0];

N_sys_eqs = size(X_0,1); % Number of system equations / states

%% Integrate with ODE solver

% Create Jacobian wrapper to match SRNN_wrapper signature
SRNN_Jacobian_wrapper = @(tt,XX) SRNN_Jacobian(tt,XX,params);

% ode_options = odeset('RelTol', 1e-11, 'AbsTol', 1e-12, 'MaxStep', 0.5*dt, 'InitialStep', min(0.001, 0.2*dt)); % accurate
% ode_options = odeset('RelTol', 1e-5, 'AbsTol', 1e-6, 'MinStep',0.05*dt,'MaxStep', 0.5*dt, 'InitialStep', 0.5*dt); % fast

if use_Jacobian 
    % ode_options = odeset('RelTol', 1e-5, 'AbsTol', 1e-6, 'MinStep', dt,'MaxStep', dt, 'InitialStep', dt, 'Jacobian', SRNN_Jacobian_wrapper); % fast
    ode_options = odeset('RelTol', 1e-7, 'AbsTol', 1e-8, 'InitialStep', 0.05*dt, 'Jacobian', SRNN_Jacobian_wrapper); % fast
else
    % ode_options = odeset('RelTol', 1e-5, 'AbsTol', 1e-6, 'MinStep', 0.1*dt,'MaxStep', dt, 'InitialStep', 0.5*dt); % fast
    ode_options = odeset('RelTol', 1e-7, 'AbsTol', 1e-8, 'MaxStep,'dt'InitialStep', 0.05*dt); % fast
end


% ode_options = odeset('RelTol', 1e-1, 'AbsTol', 1e-1, 'MaxStep', dt, 'InitialStep', dt,'MinStep',dt); % effectively single step for when using ode45 for debug

SRNN_wrapper = @(tt,XX) SRNN(tt,XX,t,u_ex,params); % inline wrapper function to add t, u_ex, and params to SRNN

% wrap ode_RKn to limit the exposure of extra parameters for usage to match builtin integrators
solver_method = 6; % 5 is classic RK4
deci = 1;
ode_RKn_wrapper = @(odefun, tspan, y0, options) deal(tspan(:), ode_RKn_deci_bounded(odefun, tspan, y0, solver_method, false, deci, get_minMaxRange(n,n_a,n_b)));

% ode_solver = ode_RKn_wrapper; 
% ode_solver = @ode45; % works fine
% ode_solver = @ode4_wrapper; 
ode_solver = @ode15s; 

% Use the wrapper instead of ode15s
[t_ode, X] = ode_solver(SRNN_wrapper, t, X_0, ode_options);

assert(all(abs(t_ode - t) < 1e-11), 'ODE solver did not return results exactly at the requested times for fiducial trajectory.');
clear t_ode % t_ode is same as t

%% comput LLE or Lyapunov spectrum

lya_dt = 0.005; % Rescaling time interval for Lyapunov calculation (tau_lya) (s)

switch lower(Lya_method)
    case 'qr'
        fprintf('Computing full Lyapunov spectrum using QR decomposition method...\n');
        
        % Ensure SRNN_jacobian_eqs is defined elsewhere or this will error.
        % Using N_sys_eqs for the number of states.
        [LE_spectrum, local_LE_spectrum_t, finite_LE_spectrum_t, t_lya] = ...
            lyapunov_spectrum_qr(X, t, lya_dt, params, ode_solver, ode_options, @SRNN_Jacobian, T, N_sys_eqs, fs);

        LE_sorted = sort(LE_spectrum,'descend');
        % Display the estimated Lyapunov Spectrum
        fprintf('----------------------------------------------------\n');
        fprintf('Estimated Lyapunov Spectrum (Global):\n');
        for i = 1:N_sys_eqs
            fprintf('  LE(%d): %f\n', i, LE_sorted(i));
        end
        fprintf('Sum of exponents: %f (should be < 0 for dissipative systems)\n', sum(LE_spectrum));
        fprintf('Kaplan-Yorke Dimension: %f\n', kaplan_yorke_dim(LE_sorted));
        fprintf('----------------------------------------------------\n');
        
    case 'benettin'
        fprintf('Computing largest Lyapunov exponent using Benettin''s algorithm...\n');
        
        d0 = 1e-3; % Initial separation magnitude for Benettin's algorithm
        [LLE, local_lya, finite_lya, t_lya] = benettin_algorithm(X, t, dt, fs, d0, T, lya_dt, params, ode_options, @SRNN, t, u_ex, ode_solver);

        fprintf('----------------------------------------------------\n');
        fprintf('Estimated Largest Lyapunov Exponent (LLE): %f\n', LLE);
        fprintf('----------------------------------------------------\n');
        
    case 'none'
        fprintf('Skipping Lyapunov calculation - trajectory only.\n');
        
    otherwise
        error('Unknown method: %s. Choose ''qr'', ''benettin'', or ''none''.', method);
end

%% Convert X to named variables
[a, b, u_d] = unpack_SRNN_state(X, n, n_a, n_b);

% compute dependent variables r and p
%% Compute dependent variables r and p using a subfunction
[r, p] = compute_dependent_variables(a, b, u_d, n_a, n_b, c_SFA);

%% Make plots using the plotting function

% Prepare Lyapunov results structure if needed
lya_results = struct();
if ~strcmpi(Lya_method, 'none')
    if strcmpi(Lya_method, 'benettin')
        if exist('LLE', 'var'), lya_results.LLE = LLE; end
        if exist('local_lya', 'var'), lya_results.local_lya = local_lya; end
        if exist('finite_lya', 'var'), lya_results.finite_lya = finite_lya; end
        if exist('t_lya', 'var'), lya_results.t_lya = t_lya; end
    elseif strcmpi(Lya_method, 'qr')
        if exist('LE_spectrum', 'var'), lya_results.LE_spectrum = LE_spectrum; end
        if exist('local_LE_spectrum_t', 'var'), lya_results.local_LE_spectrum_t = local_LE_spectrum_t; end
        if exist('finite_LE_spectrum_t', 'var'), lya_results.finite_LE_spectrum_t = finite_LE_spectrum_t; end
        if exist('t_lya', 'var'), lya_results.t_lya = t_lya; end
        if exist('N_sys_eqs', 'var'), lya_results.N_sys_eqs = N_sys_eqs; end
    end
end

% Call the plotting function
if ~strcmpi(Lya_method, 'none') && ~isempty(fieldnames(lya_results))
    SRNN_tseries_plot(t, u_ex, r, a, b, u_d, params, EI_vec, T, n, M, Lya_method, lya_results);
else
    SRNN_tseries_plot(t, u_ex, r, a, b, u_d, params, EI_vec, T, n, M, Lya_method);
end

sim_dur = toc

sim_t_dived_by_rt = sim_dur./(T(2)-T(1))